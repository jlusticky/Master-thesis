%=========================================================================
% (c) 2014, 2015 Josef Lusticky

\section{Egress traffic processing}\label{sec:linux-egress}
The previous sections described how the frame reception works and the processing path
when the routing subsystem decides to forward them.
After the routing decision is made and the {\it{skb}} is passed to the {\it{ip\_finish\_output()}} function,
it is further passed back to the link layer of the networking stack.
This part of the Linux networking also provides interface to the device drivers
and handles traffic control~\cite{understanding-internals}.

In reference to the egress traffic processing, there are two important functions in this part of the stack -
{\it{dev\_queue\_xmit()}} and {\it{dev\_hard\_start\_xmit()}}.
The {\it{ip\_finish\_output()}} function of the IPv4 stack passes the outgoing {\it{skb}}
to the {\it{dev\_queue\_xmit()}} function, which determines
whether the device is queueless of queueful.
If the device is queueless, such as Loopback or Virtual interface, then the {\it{skb}} is passed to
{\it{dev\_hard\_start\_xmit()}} directly without any traffic control mechanism involved.
The {\it{dev\_hard\_start\_xmit()}} function further prepares the {\it{skb}} for transmission
and passes it to the transmission function of the device driver,
which instructs the device to transmit the frame on the wire~\cite{understanding-internals}.

If the device is queueful, such as almost any hardware network adapter, {\it{dev\_queue\_xmit()}}
executes the traffic control first~\cite{understanding-internals}.
The traffic control implemented in the Linux kernel uses algorithms known as queuing disciplines
(often abbreviated as {\it{qdisc}})
to arrange the frames in the desired order for transmission~\cite{understanding-internals}.
Figure~\ref{fig:linux-egress-packet} shows a brief overview of this part of the stack.
\begin{figure}
	\centering
	\includegraphics[width=10cm,keepaspectratio]{fig/kernel-layer2-flow.png}
	\caption{Egress packet processing}
	\label{fig:linux-egress-packet}
	\bigskip
\end{figure}

The default queuing discipline for every network device where
no custom configuration has been applied is fifo\_fast~\cite{linux-kernel-networking}.
As the name suggests, the fifo\_fast is a classless First In First Out discipline,
that is, the first packet to get in, is going to be the first to be sent~\cite{tcpip-in-linux}.

After the packet has been selected for transmission by the traffic control, it is passed to the
{\it{ndo\_start\_xmit()}} function, which is implemented by the device driver.
The packet is inserted to the hardware transmit queue by the driver and transmitted.
The hardware transmit queue is implemented as a ring buffer (TX ring)
and the DMA controller of the device uses it to fetch the egress frames~\cite{kernel-source}.

Linux kernel supports multiple queuing disciplines, that can be configured by the {\it{tc}} utility.
A more detailed discussion of the traffic control and its queuing disciplines is outside the scope of this thesis.
Currently two qdiscs are optimised for multiqueue devices.
The first is the default pfifo\_fast qdisc.
This qdisc supports one qdisc per hardware queue.
The mq (multiqueue) qdisc is a dummy scheduler.
It is used by default for multiqueue devices instead of the regular pfifo\_fast qdisc,
but can also be attached manually to restore multiqueue behaviour
after attaching a non-multiqueue (shared) qdisc~\cite{kernel-doc-multiqueue}.

%%%%
%TODO
%%%

The networking subsystem has been assigned two different softirqs -
NET\_RX\_SOFTIRQ handles incoming traffic and NET\_TX\_SOFTIRQ handles outgoing traffic.
Because different instances of the same softirq handler can run concurrently on different CPUs,
networking code is both low latency and scalable~\cite{understanding-internals}.

\input{linux/egress-offloads.tex}
